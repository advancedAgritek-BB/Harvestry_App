"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/dashboard/cultivation/page",{

/***/ "(app-pages-browser)/./features/telemetry/services/crop-steering-data.service.ts":
/*!*******************************************************************!*\
  !*** ./features/telemetry/services/crop-steering-data.service.ts ***!
  \*******************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DEFAULT_PROFILE: function() { return /* binding */ DEFAULT_PROFILE; },\n/* harmony export */   TIME_SCALES: function() { return /* binding */ TIME_SCALES; },\n/* harmony export */   clearCropSteeringCache: function() { return /* binding */ clearCropSteeringCache; },\n/* harmony export */   formatTimeForScale: function() { return /* binding */ formatTimeForScale; },\n/* harmony export */   getCropSteeringData: function() { return /* binding */ getCropSteeringData; },\n/* harmony export */   getCurrentVwc: function() { return /* binding */ getCurrentVwc; }\n/* harmony export */ });\n// src/frontend/features/telemetry/services/crop-steering-data.service.ts\n// Generates consistent crop steering chart data with realistic P1/P2/P3 patterns\nconst TIME_SCALES = {\n    \"1m\": {\n        label: \"1M\",\n        minutes: 1,\n        dataPoints: 60,\n        intervalMs: 1000\n    },\n    \"15m\": {\n        label: \"15M\",\n        minutes: 15,\n        dataPoints: 90,\n        intervalMs: 10000\n    },\n    \"30m\": {\n        label: \"30M\",\n        minutes: 30,\n        dataPoints: 90,\n        intervalMs: 20000\n    },\n    \"1h\": {\n        label: \"1H\",\n        minutes: 60,\n        dataPoints: 60,\n        intervalMs: 60000\n    },\n    \"4h\": {\n        label: \"4H\",\n        minutes: 240,\n        dataPoints: 48,\n        intervalMs: 300000\n    },\n    \"24h\": {\n        label: \"24H\",\n        minutes: 1440,\n        dataPoints: 96,\n        intervalMs: 900000\n    }\n};\n// Seeded random number generator for consistent data\nclass SeededRandom {\n    next() {\n        // Simple LCG algorithm\n        this.seed = (this.seed * 1664525 + 1013904223) % 4294967296;\n        return this.seed / 4294967296;\n    }\n    // Get random value in range with bell curve distribution\n    gaussian(min, max) {\n        let stdDev = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0.15;\n        // Box-Muller transform for gaussian distribution\n        const u1 = this.next();\n        const u2 = this.next();\n        const z0 = Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);\n        const centered = z0 * stdDev + 0.5; // Center around 0.5\n        const clamped = Math.max(0, Math.min(1, centered));\n        return min + clamped * (max - min);\n    }\n    constructor(seed){\n        this.seed = seed;\n    }\n}\nconst DEFAULT_PROFILE = {\n    lightsOnHour: 6,\n    lightsOffHour: 18,\n    p1Duration: 180,\n    p2Duration: 360,\n    p1TargetVwc: 65,\n    p2TargetVwc: 55,\n    p3TargetVwc: 40,\n    shotVwcIncrease: 3,\n    drybackRatePerHour: 2.5\n};\n/**\n * Calculate what phase we're in based on time of day\n */ function getPhase(hour, profile) {\n    const { lightsOnHour, lightsOffHour, p1Duration, p2Duration } = profile;\n    if (hour < lightsOnHour || hour >= lightsOffHour) {\n        return \"night\";\n    }\n    const minutesSinceLightsOn = (hour - lightsOnHour) * 60;\n    if (minutesSinceLightsOn < p1Duration) {\n        return \"P1\";\n    } else if (minutesSinceLightsOn < p1Duration + p2Duration) {\n        return \"P2\";\n    } else {\n        return \"P3\";\n    }\n}\n/**\n * Calculate VWC based on phase and time with crop steering saw-tooth pattern\n */ function calculateVwc(timestamp, profile, rng) {\n    const date = new Date(timestamp);\n    const hour = date.getHours() + date.getMinutes() / 60;\n    const phase = getPhase(hour, profile);\n    const { lightsOnHour, p1Duration, p2Duration, p1TargetVwc, p2TargetVwc, p3TargetVwc, shotVwcIncrease, drybackRatePerHour } = profile;\n    let baseVwc;\n    let irrigationEvent = false;\n    const minuteOfHour = date.getMinutes();\n    switch(phase){\n        case \"night\":\n            {\n                // Night: gradual dryback from previous day's end\n                const hoursIntoNight = hour >= profile.lightsOffHour ? hour - profile.lightsOffHour : hour + (24 - profile.lightsOffHour);\n                baseVwc = p3TargetVwc - hoursIntoNight * drybackRatePerHour * 0.3;\n                baseVwc = Math.max(baseVwc, p3TargetVwc - 10);\n                break;\n            }\n        case \"P1\":\n            {\n                // P1 Ramp: Saw-tooth pattern climbing from dryback to target\n                const minutesSinceLightsOn = (hour - lightsOnHour) * 60;\n                const progressInP1 = minutesSinceLightsOn / p1Duration;\n                // Number of shots delivered so far (roughly every 30 min during P1)\n                const shotInterval = 30; // minutes between shots\n                const shotNumber = Math.floor(minutesSinceLightsOn / shotInterval);\n                const minutesSinceLastShot = minutesSinceLightsOn % shotInterval;\n                // Start from dryback target\n                const startVwc = p3TargetVwc - 5;\n                // Each shot adds VWC, but it dries back between shots\n                const vwcFromShots = shotNumber * shotVwcIncrease;\n                const drybackSinceLastShot = minutesSinceLastShot / 60 * drybackRatePerHour;\n                baseVwc = startVwc + vwcFromShots - drybackSinceLastShot;\n                baseVwc = Math.min(baseVwc, p1TargetVwc);\n                // Mark irrigation events (near shot times)\n                if (minutesSinceLastShot < 2 && shotNumber > 0) {\n                    irrigationEvent = true;\n                }\n                break;\n            }\n        case \"P2\":\n            {\n                // P2 Maintenance: Saw-tooth around maintenance target\n                const minutesSinceP1End = (hour - lightsOnHour) * 60 - p1Duration;\n                // Shots triggered when VWC drops below target (roughly every 45-60 min)\n                const shotInterval = 50;\n                const cyclePosition = minutesSinceP1End % shotInterval;\n                // Dryback within cycle\n                const drybackInCycle = cyclePosition / 60 * drybackRatePerHour;\n                // Start each cycle near target, dry back, then shot brings it back up\n                if (cyclePosition < 3) {\n                    // Just after irrigation shot\n                    baseVwc = p2TargetVwc + shotVwcIncrease - cyclePosition / 60 * drybackRatePerHour;\n                    irrigationEvent = cyclePosition < 2;\n                } else {\n                    // Drying back phase\n                    baseVwc = p2TargetVwc + shotVwcIncrease - drybackInCycle;\n                }\n                break;\n            }\n        case \"P3\":\n            {\n                // P3 Dryback: Steady decline toward dryback target\n                const minutesSinceP2End = (hour - lightsOnHour) * 60 - p1Duration - p2Duration;\n                const p3TotalMinutes = (profile.lightsOffHour - lightsOnHour) * 60 - p1Duration - p2Duration;\n                const progressInP3 = minutesSinceP2End / p3TotalMinutes;\n                // Linear decline from P2 target to P3 target\n                baseVwc = p2TargetVwc - progressInP3 * (p2TargetVwc - p3TargetVwc);\n                break;\n            }\n    }\n    // Add small noise\n    const noise = rng.gaussian(-0.5, 0.5, 0.3);\n    return {\n        vwc: Math.max(30, Math.min(80, baseVwc + noise)),\n        irrigationEvent\n    };\n}\n/**\n * Calculate environmental values based on time and phase\n */ function calculateEnvironmentals(timestamp, profile, rng) {\n    const date = new Date(timestamp);\n    const hour = date.getHours() + date.getMinutes() / 60;\n    const phase = getPhase(hour, profile);\n    const isLightsOn = phase !== \"night\";\n    // Temperature: Higher during lights on\n    const baseTemp = isLightsOn ? 78 : 72;\n    const temp = baseTemp + rng.gaussian(-1, 1);\n    // RH: Inverse to temp, higher at night\n    const baseRh = isLightsOn ? 55 : 65;\n    const rh = baseRh + rng.gaussian(-2, 2);\n    // VPD: Calculated from temp and RH (simplified)\n    const vpd = isLightsOn ? 1.1 + rng.gaussian(-0.1, 0.1) : 0.8 + rng.gaussian(-0.05, 0.05);\n    // CO2: Enriched during lights on\n    const co2 = isLightsOn ? 1000 + rng.gaussian(-30, 30) : 450 + rng.gaussian(-20, 20);\n    // PPFD: Only during lights on\n    const ppfd = isLightsOn ? 900 + rng.gaussian(-30, 30) : 0;\n    return {\n        temp,\n        rh,\n        vpd,\n        co2,\n        ppfd\n    };\n}\n/**\n * Format timestamp for display based on time scale\n */ function formatTimeForScale(date, scale) {\n    if (scale === \"1m\") {\n        return \"\".concat(date.getMinutes(), \":\").concat(String(date.getSeconds()).padStart(2, \"0\"));\n    } else if (scale === \"24h\") {\n        return \"\".concat(String(date.getHours()).padStart(2, \"0\"), \":\").concat(String(date.getMinutes()).padStart(2, \"0\"));\n    } else {\n        return \"\".concat(date.getHours(), \":\").concat(String(date.getMinutes()).padStart(2, \"0\"));\n    }\n}\n/**\n * Generate a single data point for a specific timestamp\n */ function generateDataPoint(timestamp, scale, profile, rng) {\n    const date = new Date(timestamp);\n    const hour = date.getHours() + date.getMinutes() / 60;\n    const phase = getPhase(hour, profile);\n    const { vwc, irrigationEvent } = calculateVwc(timestamp, profile, rng);\n    const environmentals = calculateEnvironmentals(timestamp, profile, rng);\n    return {\n        timestamp,\n        time: formatTimeForScale(date, scale),\n        vwc,\n        phase,\n        irrigationEvent,\n        ...environmentals\n    };\n}\n// Cache for storing high-resolution base data\nlet baseDataCache = [];\nlet baseCacheTimestamp = 0;\nconst BASE_RESOLUTION_MS = 1000; // 1 second resolution for base data\nconst BASE_DATA_DURATION_MS = 24 * 60 * 60 * 1000; // 24 hours of data\n/**\n * Generate or retrieve base high-resolution data\n * This ensures consistency across all time scales\n */ function getBaseData() {\n    let profile = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : DEFAULT_PROFILE;\n    const now = Date.now();\n    // Regenerate if cache is stale (older than 30 seconds) or empty\n    if (!baseDataCache.length || now - baseCacheTimestamp > 30000) {\n        baseCacheTimestamp = now;\n        // Use a seed based on the start of the current day for consistency\n        const dayStart = new Date();\n        dayStart.setHours(0, 0, 0, 0);\n        const seed = dayStart.getTime();\n        const rng = new SeededRandom(seed);\n        baseDataCache = [];\n        const startTime = now - BASE_DATA_DURATION_MS;\n        // Generate data at 1-minute resolution for efficiency (upgrade from 1s)\n        const resolutionMs = 60000; // 1 minute\n        const dataPoints = Math.floor(BASE_DATA_DURATION_MS / resolutionMs);\n        for(let i = 0; i < dataPoints; i++){\n            const timestamp = startTime + i * resolutionMs;\n            baseDataCache.push(generateDataPoint(timestamp, \"1m\", profile, rng));\n        }\n    }\n    return baseDataCache;\n}\n/**\n * Aggregate data points by averaging values within time buckets\n */ function aggregateDataPoints(data, bucketSizeMs, scale) {\n    if (data.length === 0) return [];\n    const buckets = new Map();\n    // Group data into buckets\n    for (const point of data){\n        const bucketKey = Math.floor(point.timestamp / bucketSizeMs) * bucketSizeMs;\n        if (!buckets.has(bucketKey)) {\n            buckets.set(bucketKey, []);\n        }\n        buckets.get(bucketKey).push(point);\n    }\n    // Aggregate each bucket\n    const result = [];\n    const sortedKeys = Array.from(buckets.keys()).sort((a, b)=>a - b);\n    for (const bucketKey of sortedKeys){\n        const points = buckets.get(bucketKey);\n        const avgPoint = {\n            timestamp: bucketKey,\n            time: formatTimeForScale(new Date(bucketKey), scale),\n            vwc: points.reduce((sum, p)=>sum + p.vwc, 0) / points.length,\n            temp: points.reduce((sum, p)=>sum + p.temp, 0) / points.length,\n            rh: points.reduce((sum, p)=>sum + p.rh, 0) / points.length,\n            vpd: points.reduce((sum, p)=>sum + p.vpd, 0) / points.length,\n            co2: points.reduce((sum, p)=>sum + p.co2, 0) / points.length,\n            ppfd: points.reduce((sum, p)=>sum + p.ppfd, 0) / points.length,\n            phase: points[Math.floor(points.length / 2)].phase,\n            irrigationEvent: points.some((p)=>p.irrigationEvent)\n        };\n        result.push(avgPoint);\n    }\n    return result;\n}\n/**\n * Generate high-resolution data for 1m scale (1-second intervals)\n * This is generated on-demand since it's a short time window\n */ function generate1mData(profile) {\n    const now = Date.now();\n    const config = TIME_SCALES[\"1m\"];\n    const intervalMs = config.intervalMs; // 1000ms\n    const dataPoints = config.dataPoints; // 60 points\n    // Use a seed based on the current minute for consistency within that minute\n    const minuteStart = Math.floor(now / 60000) * 60000;\n    const rng = new SeededRandom(minuteStart);\n    const result = [];\n    const startTime = now - dataPoints * intervalMs;\n    for(let i = 0; i < dataPoints; i++){\n        const timestamp = startTime + i * intervalMs;\n        result.push(generateDataPoint(timestamp, \"1m\", profile, rng));\n    }\n    return result;\n}\n/**\n * Main function: Get crop steering data for a specific time scale\n * Data is consistent across time scales - shorter scales show more detail,\n * longer scales show aggregated/downsampled data\n */ function getCropSteeringData(scale) {\n    let profile = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : DEFAULT_PROFILE;\n    const config = TIME_SCALES[scale];\n    const now = Date.now();\n    const windowMs = config.minutes * 60 * 1000;\n    const startTime = now - windowMs;\n    // Special handling for 1m scale - generate at 1-second resolution\n    if (scale === \"1m\") {\n        return generate1mData(profile);\n    }\n    // Get base data (1-minute resolution)\n    const baseData = getBaseData(profile);\n    // Filter to time window\n    const windowData = baseData.filter((p)=>p.timestamp >= startTime && p.timestamp <= now);\n    // If we don't have enough data points, return what we have\n    if (windowData.length === 0) {\n        // Generate some data for the window\n        const rng = new SeededRandom(Math.floor(now / 60000));\n        const result = [];\n        const intervalMs = windowMs / config.dataPoints;\n        for(let i = 0; i < config.dataPoints; i++){\n            const timestamp = startTime + i * intervalMs;\n            result.push(generateDataPoint(timestamp, scale, profile, rng));\n        }\n        return result;\n    }\n    // Calculate bucket size for aggregation\n    const bucketSizeMs = windowMs / config.dataPoints;\n    // Aggregate if needed (for longer time scales)\n    if (bucketSizeMs > 60000) {\n        return aggregateDataPoints(windowData, bucketSizeMs, scale);\n    }\n    // For short time scales, just sample\n    const targetCount = config.dataPoints;\n    if (windowData.length <= targetCount) {\n        return windowData.map((p)=>({\n                ...p,\n                time: formatTimeForScale(new Date(p.timestamp), scale)\n            }));\n    }\n    // Downsample evenly\n    const result = [];\n    const step = windowData.length / targetCount;\n    for(let i = 0; i < targetCount; i++){\n        const idx = Math.floor(i * step);\n        const point = windowData[idx];\n        result.push({\n            ...point,\n            time: formatTimeForScale(new Date(point.timestamp), scale)\n        });\n    }\n    return result;\n}\n/**\n * Clear the cache - useful for testing or forcing data regeneration\n */ function clearCropSteeringCache() {\n    baseDataCache = [];\n    baseCacheTimestamp = 0;\n}\n/**\n * Get current VWC value (latest from base data)\n */ function getCurrentVwc() {\n    const data = getBaseData();\n    return data.length > 0 ? data[data.length - 1].vwc : 50;\n}\n\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2ZlYXR1cmVzL3RlbGVtZXRyeS9zZXJ2aWNlcy9jcm9wLXN0ZWVyaW5nLWRhdGEuc2VydmljZS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQSx5RUFBeUU7QUFDekUsaUZBQWlGO0FBd0IxRSxNQUFNQSxjQUFrRDtJQUM3RCxNQUFNO1FBQUVDLE9BQU87UUFBTUMsU0FBUztRQUFHQyxZQUFZO1FBQUlDLFlBQVk7SUFBSztJQUNsRSxPQUFPO1FBQUVILE9BQU87UUFBT0MsU0FBUztRQUFJQyxZQUFZO1FBQUlDLFlBQVk7SUFBTTtJQUN0RSxPQUFPO1FBQUVILE9BQU87UUFBT0MsU0FBUztRQUFJQyxZQUFZO1FBQUlDLFlBQVk7SUFBTTtJQUN0RSxNQUFNO1FBQUVILE9BQU87UUFBTUMsU0FBUztRQUFJQyxZQUFZO1FBQUlDLFlBQVk7SUFBTTtJQUNwRSxNQUFNO1FBQUVILE9BQU87UUFBTUMsU0FBUztRQUFLQyxZQUFZO1FBQUlDLFlBQVk7SUFBTztJQUN0RSxPQUFPO1FBQUVILE9BQU87UUFBT0MsU0FBUztRQUFNQyxZQUFZO1FBQUlDLFlBQVk7SUFBTztBQUMzRSxFQUFFO0FBRUYscURBQXFEO0FBQ3JELE1BQU1DO0lBT0pDLE9BQWU7UUFDYix1QkFBdUI7UUFDdkIsSUFBSSxDQUFDQyxJQUFJLEdBQUcsQ0FBQyxJQUFJLENBQUNBLElBQUksR0FBRyxVQUFVLFVBQVMsSUFBSztRQUNqRCxPQUFPLElBQUksQ0FBQ0EsSUFBSSxHQUFHO0lBQ3JCO0lBRUEseURBQXlEO0lBQ3pEQyxTQUFTQyxHQUFXLEVBQUVDLEdBQVcsRUFBaUM7WUFBL0JDLFNBQUFBLGlFQUFpQjtRQUNsRCxpREFBaUQ7UUFDakQsTUFBTUMsS0FBSyxJQUFJLENBQUNOLElBQUk7UUFDcEIsTUFBTU8sS0FBSyxJQUFJLENBQUNQLElBQUk7UUFDcEIsTUFBTVEsS0FBS0MsS0FBS0MsSUFBSSxDQUFDLENBQUMsSUFBSUQsS0FBS0UsR0FBRyxDQUFDTCxP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Z0IsRUFBRTtJQUNsQkMscUJBQXFCO0FBQ3ZCO0FBRUE7O0NBRUMsR0FDTSxTQUFTa0Q7SUFDZCxNQUFNcEMsT0FBT1g7SUFDYixPQUFPVyxLQUFLVCxNQUFNLEdBQUcsSUFBSVMsSUFBSSxDQUFDQSxLQUFLVCxNQUFNLEdBQUcsRUFBRSxDQUFDeEIsR0FBRyxHQUFHO0FBQ3ZEO0FBRXFEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2ZlYXR1cmVzL3RlbGVtZXRyeS9zZXJ2aWNlcy9jcm9wLXN0ZWVyaW5nLWRhdGEuc2VydmljZS50cz9mZjY2Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy9mcm9udGVuZC9mZWF0dXJlcy90ZWxlbWV0cnkvc2VydmljZXMvY3JvcC1zdGVlcmluZy1kYXRhLnNlcnZpY2UudHNcbi8vIEdlbmVyYXRlcyBjb25zaXN0ZW50IGNyb3Agc3RlZXJpbmcgY2hhcnQgZGF0YSB3aXRoIHJlYWxpc3RpYyBQMS9QMi9QMyBwYXR0ZXJuc1xuXG5leHBvcnQgaW50ZXJmYWNlIENyb3BTdGVlcmluZ0RhdGFQb2ludCB7XG4gIHRpbWVzdGFtcDogbnVtYmVyO1xuICB0aW1lOiBzdHJpbmc7XG4gIHZ3YzogbnVtYmVyO1xuICB0ZW1wOiBudW1iZXI7XG4gIHJoOiBudW1iZXI7XG4gIHZwZDogbnVtYmVyO1xuICBjbzI6IG51bWJlcjtcbiAgcHBmZDogbnVtYmVyO1xuICBwaGFzZTogJ1AxJyB8ICdQMicgfCAnUDMnIHwgJ25pZ2h0JztcbiAgaXJyaWdhdGlvbkV2ZW50PzogYm9vbGVhbjtcbn1cblxuZXhwb3J0IHR5cGUgVGltZVNjYWxlID0gJzFtJyB8ICcxNW0nIHwgJzMwbScgfCAnMWgnIHwgJzRoJyB8ICcyNGgnO1xuXG5pbnRlcmZhY2UgVGltZVNjYWxlQ29uZmlnIHtcbiAgbGFiZWw6IHN0cmluZztcbiAgbWludXRlczogbnVtYmVyO1xuICBkYXRhUG9pbnRzOiBudW1iZXI7XG4gIGludGVydmFsTXM6IG51bWJlcjtcbn1cblxuZXhwb3J0IGNvbnN0IFRJTUVfU0NBTEVTOiBSZWNvcmQ8VGltZVNjYWxlLCBUaW1lU2NhbGVDb25maWc+ID0ge1xuICAnMW0nOiB7IGxhYmVsOiAnMU0nLCBtaW51dGVzOiAxLCBkYXRhUG9pbnRzOiA2MCwgaW50ZXJ2YWxNczogMTAwMCB9LFxuICAnMTVtJzogeyBsYWJlbDogJzE1TScsIG1pbnV0ZXM6IDE1LCBkYXRhUG9pbnRzOiA5MCwgaW50ZXJ2YWxNczogMTAwMDAgfSxcbiAgJzMwbSc6IHsgbGFiZWw6ICczME0nLCBtaW51dGVzOiAzMCwgZGF0YVBvaW50czogOTAsIGludGVydmFsTXM6IDIwMDAwIH0sXG4gICcxaCc6IHsgbGFiZWw6ICcxSCcsIG1pbnV0ZXM6IDYwLCBkYXRhUG9pbnRzOiA2MCwgaW50ZXJ2YWxNczogNjAwMDAgfSxcbiAgJzRoJzogeyBsYWJlbDogJzRIJywgbWludXRlczogMjQwLCBkYXRhUG9pbnRzOiA0OCwgaW50ZXJ2YWxNczogMzAwMDAwIH0sXG4gICcyNGgnOiB7IGxhYmVsOiAnMjRIJywgbWludXRlczogMTQ0MCwgZGF0YVBvaW50czogOTYsIGludGVydmFsTXM6IDkwMDAwMCB9LFxufTtcblxuLy8gU2VlZGVkIHJhbmRvbSBudW1iZXIgZ2VuZXJhdG9yIGZvciBjb25zaXN0ZW50IGRhdGFcbmNsYXNzIFNlZWRlZFJhbmRvbSB7XG4gIHByaXZhdGUgc2VlZDogbnVtYmVyO1xuXG4gIGNvbnN0cnVjdG9yKHNlZWQ6IG51bWJlcikge1xuICAgIHRoaXMuc2VlZCA9IHNlZWQ7XG4gIH1cblxuICBuZXh0KCk6IG51bWJlciB7XG4gICAgLy8gU2ltcGxlIExDRyBhbGdvcml0aG1cbiAgICB0aGlzLnNlZWQgPSAodGhpcy5zZWVkICogMTY2NDUyNSArIDEwMTM5MDQyMjMpICUgNDI5NDk2NzI5NjtcbiAgICByZXR1cm4gdGhpcy5zZWVkIC8gNDI5NDk2NzI5NjtcbiAgfVxuXG4gIC8vIEdldCByYW5kb20gdmFsdWUgaW4gcmFuZ2Ugd2l0aCBiZWxsIGN1cnZlIGRpc3RyaWJ1dGlvblxuICBnYXVzc2lhbihtaW46IG51bWJlciwgbWF4OiBudW1iZXIsIHN0ZERldjogbnVtYmVyID0gMC4xNSk6IG51bWJlciB7XG4gICAgLy8gQm94LU11bGxlciB0cmFuc2Zvcm0gZm9yIGdhdXNzaWFuIGRpc3RyaWJ1dGlvblxuICAgIGNvbnN0IHUxID0gdGhpcy5uZXh0KCk7XG4gICAgY29uc3QgdTIgPSB0aGlzLm5leHQoKTtcbiAgICBjb25zdCB6MCA9IE1hdGguc3FydCgtMiAqIE1hdGgubG9nKHUxKSkgKiBNYXRoLmNvcygyICogTWF0aC5QSSAqIHUyKTtcbiAgICBjb25zdCBjZW50ZXJlZCA9IHowICogc3RkRGV2ICsgMC41OyAvLyBDZW50ZXIgYXJvdW5kIDAuNVxuICAgIGNvbnN0IGNsYW1wZWQgPSBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCBjZW50ZXJlZCkpO1xuICAgIHJldHVybiBtaW4gKyBjbGFtcGVkICogKG1heCAtIG1pbik7XG4gIH1cbn1cblxuLy8gQ3JvcCBzdGVlcmluZyBwcm9maWxlIGNvbmZpZ3VyYXRpb25cbmludGVyZmFjZSBDcm9wU3RlZXJpbmdQcm9maWxlIHtcbiAgbGlnaHRzT25Ib3VyOiBudW1iZXI7XG4gIGxpZ2h0c09mZkhvdXI6IG51bWJlcjtcbiAgcDFEdXJhdGlvbjogbnVtYmVyOyAgICAgIC8vIE1pbnV0ZXMgZm9yIFAxIChyYW1wKSBwaGFzZVxuICBwMkR1cmF0aW9uOiBudW1iZXI7ICAgICAgLy8gTWludXRlcyBmb3IgUDIgKG1haW50ZW5hbmNlKSBwaGFzZVxuICBwMVRhcmdldFZ3YzogbnVtYmVyOyAgICAgLy8gVGFyZ2V0IFZXQyBhdCBlbmQgb2YgUDFcbiAgcDJUYXJnZXRWd2M6IG51bWJlcjsgICAgIC8vIE1haW50ZW5hbmNlIFZXQyB0YXJnZXRcbiAgcDNUYXJnZXRWd2M6IG51bWJlcjsgICAgIC8vIERyeWJhY2sgdGFyZ2V0IChlbmQgb2YgUDMgLyBzdGFydCBvZiBuZXh0IGRheSlcbiAgc2hvdFZ3Y0luY3JlYXNlOiBudW1iZXI7IC8vIFZXQyBpbmNyZWFzZSBwZXIgaXJyaWdhdGlvbiBzaG90XG4gIGRyeWJhY2tSYXRlUGVySG91cjogbnVtYmVyOyAvLyBOYXR1cmFsIFZXQyBkZWNsaW5lIHBlciBob3VyXG59XG5cbmNvbnN0IERFRkFVTFRfUFJPRklMRTogQ3JvcFN0ZWVyaW5nUHJvZmlsZSA9IHtcbiAgbGlnaHRzT25Ib3VyOiA2LFxuICBsaWdodHNPZmZIb3VyOiAxOCxcbiAgcDFEdXJhdGlvbjogMTgwLCAgICAgICAgLy8gMyBob3VycyBmb3IgcmFtcFxuICBwMkR1cmF0aW9uOiAzNjAsICAgICAgICAvLyA2IGhvdXJzIGZvciBtYWludGVuYW5jZVxuICBwMVRhcmdldFZ3YzogNjUsXG4gIHAyVGFyZ2V0VndjOiA1NSxcbiAgcDNUYXJnZXRWd2M6IDQwLFxuICBzaG90VndjSW5jcmVhc2U6IDMsICAgICAvLyB+MyUgcGVyIHNob3RcbiAgZHJ5YmFja1JhdGVQZXJIb3VyOiAyLjUsXG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZSB3aGF0IHBoYXNlIHdlJ3JlIGluIGJhc2VkIG9uIHRpbWUgb2YgZGF5XG4gKi9cbmZ1bmN0aW9uIGdldFBoYXNlKGhvdXI6IG51bWJlciwgcHJvZmlsZTogQ3JvcFN0ZWVyaW5nUHJvZmlsZSk6ICdQMScgfCAnUDInIHwgJ1AzJyB8ICduaWdodCcge1xuICBjb25zdCB7IGxpZ2h0c09uSG91ciwgbGlnaHRzT2ZmSG91ciwgcDFEdXJhdGlvbiwgcDJEdXJhdGlvbiB9ID0gcHJvZmlsZTtcbiAgXG4gIGlmIChob3VyIDwgbGlnaHRzT25Ib3VyIHx8IGhvdXIgPj0gbGlnaHRzT2ZmSG91cikge1xuICAgIHJldHVybiAnbmlnaHQnO1xuICB9XG4gIFxuICBjb25zdCBtaW51dGVzU2luY2VMaWdodHNPbiA9IChob3VyIC0gbGlnaHRzT25Ib3VyKSAqIDYwO1xuICBcbiAgaWYgKG1pbnV0ZXNTaW5jZUxpZ2h0c09uIDwgcDFEdXJhdGlvbikge1xuICAgIHJldHVybiAnUDEnO1xuICB9IGVsc2UgaWYgKG1pbnV0ZXNTaW5jZUxpZ2h0c09uIDwgcDFEdXJhdGlvbiArIHAyRHVyYXRpb24pIHtcbiAgICByZXR1cm4gJ1AyJztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gJ1AzJztcbiAgfVxufVxuXG4vKipcbiAqIENhbGN1bGF0ZSBWV0MgYmFzZWQgb24gcGhhc2UgYW5kIHRpbWUgd2l0aCBjcm9wIHN0ZWVyaW5nIHNhdy10b290aCBwYXR0ZXJuXG4gKi9cbmZ1bmN0aW9uIGNhbGN1bGF0ZVZ3YyhcbiAgdGltZXN0YW1wOiBudW1iZXIsXG4gIHByb2ZpbGU6IENyb3BTdGVlcmluZ1Byb2ZpbGUsXG4gIHJuZzogU2VlZGVkUmFuZG9tXG4pOiB7IHZ3YzogbnVtYmVyOyBpcnJpZ2F0aW9uRXZlbnQ6IGJvb2xlYW4gfSB7XG4gIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZSh0aW1lc3RhbXApO1xuICBjb25zdCBob3VyID0gZGF0ZS5nZXRIb3VycygpICsgZGF0ZS5nZXRNaW51dGVzKCkgLyA2MDtcbiAgY29uc3QgcGhhc2UgPSBnZXRQaGFzZShob3VyLCBwcm9maWxlKTtcbiAgXG4gIGNvbnN0IHsgbGlnaHRzT25Ib3VyLCBwMUR1cmF0aW9uLCBwMkR1cmF0aW9uLCBwMVRhcmdldFZ3YywgcDJUYXJnZXRWd2MsIHAzVGFyZ2V0VndjLCBzaG90VndjSW5jcmVhc2UsIGRyeWJhY2tSYXRlUGVySG91ciB9ID0gcHJvZmlsZTtcbiAgXG4gIGxldCBiYXNlVndjOiBudW1iZXI7XG4gIGxldCBpcnJpZ2F0aW9uRXZlbnQgPSBmYWxzZTtcbiAgY29uc3QgbWludXRlT2ZIb3VyID0gZGF0ZS5nZXRNaW51dGVzKCk7XG4gIFxuICBzd2l0Y2ggKHBoYXNlKSB7XG4gICAgY2FzZSAnbmlnaHQnOiB7XG4gICAgICAvLyBOaWdodDogZ3JhZHVhbCBkcnliYWNrIGZyb20gcHJldmlvdXMgZGF5J3MgZW5kXG4gICAgICBjb25zdCBob3Vyc0ludG9OaWdodCA9IGhvdXIgPj0gcHJvZmlsZS5saWdodHNPZmZIb3VyIFxuICAgICAgICA/IGhvdXIgLSBwcm9maWxlLmxpZ2h0c09mZkhvdXIgXG4gICAgICAgIDogaG91ciArICgyNCAtIHByb2ZpbGUubGlnaHRzT2ZmSG91cik7XG4gICAgICBiYXNlVndjID0gcDNUYXJnZXRWd2MgLSAoaG91cnNJbnRvTmlnaHQgKiBkcnliYWNrUmF0ZVBlckhvdXIgKiAwLjMpO1xuICAgICAgYmFzZVZ3YyA9IE1hdGgubWF4KGJhc2VWd2MsIHAzVGFyZ2V0VndjIC0gMTApO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIFxuICAgIGNhc2UgJ1AxJzoge1xuICAgICAgLy8gUDEgUmFtcDogU2F3LXRvb3RoIHBhdHRlcm4gY2xpbWJpbmcgZnJvbSBkcnliYWNrIHRvIHRhcmdldFxuICAgICAgY29uc3QgbWludXRlc1NpbmNlTGlnaHRzT24gPSAoaG91ciAtIGxpZ2h0c09uSG91cikgKiA2MDtcbiAgICAgIGNvbnN0IHByb2dyZXNzSW5QMSA9IG1pbnV0ZXNTaW5jZUxpZ2h0c09uIC8gcDFEdXJhdGlvbjtcbiAgICAgIFxuICAgICAgLy8gTnVtYmVyIG9mIHNob3RzIGRlbGl2ZXJlZCBzbyBmYXIgKHJvdWdobHkgZXZlcnkgMzAgbWluIGR1cmluZyBQMSlcbiAgICAgIGNvbnN0IHNob3RJbnRlcnZhbCA9IDMwOyAvLyBtaW51dGVzIGJldHdlZW4gc2hvdHNcbiAgICAgIGNvbnN0IHNob3ROdW1iZXIgPSBNYXRoLmZsb29yKG1pbnV0ZXNTaW5jZUxpZ2h0c09uIC8gc2hvdEludGVydmFsKTtcbiAgICAgIGNvbnN0IG1pbnV0ZXNTaW5jZUxhc3RTaG90ID0gbWludXRlc1NpbmNlTGlnaHRzT24gJSBzaG90SW50ZXJ2YWw7XG4gICAgICBcbiAgICAgIC8vIFN0YXJ0IGZyb20gZHJ5YmFjayB0YXJnZXRcbiAgICAgIGNvbnN0IHN0YXJ0VndjID0gcDNUYXJnZXRWd2MgLSA1O1xuICAgICAgXG4gICAgICAvLyBFYWNoIHNob3QgYWRkcyBWV0MsIGJ1dCBpdCBkcmllcyBiYWNrIGJldHdlZW4gc2hvdHNcbiAgICAgIGNvbnN0IHZ3Y0Zyb21TaG90cyA9IHNob3ROdW1iZXIgKiBzaG90VndjSW5jcmVhc2U7XG4gICAgICBjb25zdCBkcnliYWNrU2luY2VMYXN0U2hvdCA9IChtaW51dGVzU2luY2VMYXN0U2hvdCAvIDYwKSAqIGRyeWJhY2tSYXRlUGVySG91cjtcbiAgICAgIFxuICAgICAgYmFzZVZ3YyA9IHN0YXJ0VndjICsgdndjRnJvbVNob3RzIC0gZHJ5YmFja1NpbmNlTGFzdFNob3Q7XG4gICAgICBiYXNlVndjID0gTWF0aC5taW4oYmFzZVZ3YywgcDFUYXJnZXRWd2MpO1xuICAgICAgXG4gICAgICAvLyBNYXJrIGlycmlnYXRpb24gZXZlbnRzIChuZWFyIHNob3QgdGltZXMpXG4gICAgICBpZiAobWludXRlc1NpbmNlTGFzdFNob3QgPCAyICYmIHNob3ROdW1iZXIgPiAwKSB7XG4gICAgICAgIGlycmlnYXRpb25FdmVudCA9IHRydWU7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgXG4gICAgY2FzZSAnUDInOiB7XG4gICAgICAvLyBQMiBNYWludGVuYW5jZTogU2F3LXRvb3RoIGFyb3VuZCBtYWludGVuYW5jZSB0YXJnZXRcbiAgICAgIGNvbnN0IG1pbnV0ZXNTaW5jZVAxRW5kID0gKChob3VyIC0gbGlnaHRzT25Ib3VyKSAqIDYwKSAtIHAxRHVyYXRpb247XG4gICAgICBcbiAgICAgIC8vIFNob3RzIHRyaWdnZXJlZCB3aGVuIFZXQyBkcm9wcyBiZWxvdyB0YXJnZXQgKHJvdWdobHkgZXZlcnkgNDUtNjAgbWluKVxuICAgICAgY29uc3Qgc2hvdEludGVydmFsID0gNTA7XG4gICAgICBjb25zdCBjeWNsZVBvc2l0aW9uID0gbWludXRlc1NpbmNlUDFFbmQgJSBzaG90SW50ZXJ2YWw7XG4gICAgICBcbiAgICAgIC8vIERyeWJhY2sgd2l0aGluIGN5Y2xlXG4gICAgICBjb25zdCBkcnliYWNrSW5DeWNsZSA9IChjeWNsZVBvc2l0aW9uIC8gNjApICogZHJ5YmFja1JhdGVQZXJIb3VyO1xuICAgICAgXG4gICAgICAvLyBTdGFydCBlYWNoIGN5Y2xlIG5lYXIgdGFyZ2V0LCBkcnkgYmFjaywgdGhlbiBzaG90IGJyaW5ncyBpdCBiYWNrIHVwXG4gICAgICBpZiAoY3ljbGVQb3NpdGlvbiA8IDMpIHtcbiAgICAgICAgLy8gSnVzdCBhZnRlciBpcnJpZ2F0aW9uIHNob3RcbiAgICAgICAgYmFzZVZ3YyA9IHAyVGFyZ2V0VndjICsgc2hvdFZ3Y0luY3JlYXNlIC0gKGN5Y2xlUG9zaXRpb24gLyA2MCkgKiBkcnliYWNrUmF0ZVBlckhvdXI7XG4gICAgICAgIGlycmlnYXRpb25FdmVudCA9IGN5Y2xlUG9zaXRpb24gPCAyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRHJ5aW5nIGJhY2sgcGhhc2VcbiAgICAgICAgYmFzZVZ3YyA9IHAyVGFyZ2V0VndjICsgc2hvdFZ3Y0luY3JlYXNlIC0gZHJ5YmFja0luQ3ljbGU7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgXG4gICAgY2FzZSAnUDMnOiB7XG4gICAgICAvLyBQMyBEcnliYWNrOiBTdGVhZHkgZGVjbGluZSB0b3dhcmQgZHJ5YmFjayB0YXJnZXRcbiAgICAgIGNvbnN0IG1pbnV0ZXNTaW5jZVAyRW5kID0gKChob3VyIC0gbGlnaHRzT25Ib3VyKSAqIDYwKSAtIHAxRHVyYXRpb24gLSBwMkR1cmF0aW9uO1xuICAgICAgY29uc3QgcDNUb3RhbE1pbnV0ZXMgPSAocHJvZmlsZS5saWdodHNPZmZIb3VyIC0gbGlnaHRzT25Ib3VyKSAqIDYwIC0gcDFEdXJhdGlvbiAtIHAyRHVyYXRpb247XG4gICAgICBjb25zdCBwcm9ncmVzc0luUDMgPSBtaW51dGVzU2luY2VQMkVuZCAvIHAzVG90YWxNaW51dGVzO1xuICAgICAgXG4gICAgICAvLyBMaW5lYXIgZGVjbGluZSBmcm9tIFAyIHRhcmdldCB0byBQMyB0YXJnZXRcbiAgICAgIGJhc2VWd2MgPSBwMlRhcmdldFZ3YyAtIChwcm9ncmVzc0luUDMgKiAocDJUYXJnZXRWd2MgLSBwM1RhcmdldFZ3YykpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIFxuICAvLyBBZGQgc21hbGwgbm9pc2VcbiAgY29uc3Qgbm9pc2UgPSBybmcuZ2F1c3NpYW4oLTAuNSwgMC41LCAwLjMpO1xuICBcbiAgcmV0dXJuIHtcbiAgICB2d2M6IE1hdGgubWF4KDMwLCBNYXRoLm1pbig4MCwgYmFzZVZ3YyArIG5vaXNlKSksXG4gICAgaXJyaWdhdGlvbkV2ZW50LFxuICB9O1xufVxuXG4vKipcbiAqIENhbGN1bGF0ZSBlbnZpcm9ubWVudGFsIHZhbHVlcyBiYXNlZCBvbiB0aW1lIGFuZCBwaGFzZVxuICovXG5mdW5jdGlvbiBjYWxjdWxhdGVFbnZpcm9ubWVudGFscyhcbiAgdGltZXN0YW1wOiBudW1iZXIsXG4gIHByb2ZpbGU6IENyb3BTdGVlcmluZ1Byb2ZpbGUsXG4gIHJuZzogU2VlZGVkUmFuZG9tXG4pOiB7IHRlbXA6IG51bWJlcjsgcmg6IG51bWJlcjsgdnBkOiBudW1iZXI7IGNvMjogbnVtYmVyOyBwcGZkOiBudW1iZXIgfSB7XG4gIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZSh0aW1lc3RhbXApO1xuICBjb25zdCBob3VyID0gZGF0ZS5nZXRIb3VycygpICsgZGF0ZS5nZXRNaW51dGVzKCkgLyA2MDtcbiAgY29uc3QgcGhhc2UgPSBnZXRQaGFzZShob3VyLCBwcm9maWxlKTtcbiAgXG4gIGNvbnN0IGlzTGlnaHRzT24gPSBwaGFzZSAhPT0gJ25pZ2h0JztcbiAgXG4gIC8vIFRlbXBlcmF0dXJlOiBIaWdoZXIgZHVyaW5nIGxpZ2h0cyBvblxuICBjb25zdCBiYXNlVGVtcCA9IGlzTGlnaHRzT24gPyA3OCA6IDcyO1xuICBjb25zdCB0ZW1wID0gYmFzZVRlbXAgKyBybmcuZ2F1c3NpYW4oLTEsIDEpO1xuICBcbiAgLy8gUkg6IEludmVyc2UgdG8gdGVtcCwgaGlnaGVyIGF0IG5pZ2h0XG4gIGNvbnN0IGJhc2VSaCA9IGlzTGlnaHRzT24gPyA1NSA6IDY1O1xuICBjb25zdCByaCA9IGJhc2VSaCArIHJuZy5nYXVzc2lhbigtMiwgMik7XG4gIFxuICAvLyBWUEQ6IENhbGN1bGF0ZWQgZnJvbSB0ZW1wIGFuZCBSSCAoc2ltcGxpZmllZClcbiAgY29uc3QgdnBkID0gaXNMaWdodHNPbiA/IDEuMSArIHJuZy5nYXVzc2lhbigtMC4xLCAwLjEpIDogMC44ICsgcm5nLmdhdXNzaWFuKC0wLjA1LCAwLjA1KTtcbiAgXG4gIC8vIENPMjogRW5yaWNoZWQgZHVyaW5nIGxpZ2h0cyBvblxuICBjb25zdCBjbzIgPSBpc0xpZ2h0c09uID8gMTAwMCArIHJuZy5nYXVzc2lhbigtMzAsIDMwKSA6IDQ1MCArIHJuZy5nYXVzc2lhbigtMjAsIDIwKTtcbiAgXG4gIC8vIFBQRkQ6IE9ubHkgZHVyaW5nIGxpZ2h0cyBvblxuICBjb25zdCBwcGZkID0gaXNMaWdodHNPbiA/IDkwMCArIHJuZy5nYXVzc2lhbigtMzAsIDMwKSA6IDA7XG4gIFxuICByZXR1cm4geyB0ZW1wLCByaCwgdnBkLCBjbzIsIHBwZmQgfTtcbn1cblxuLyoqXG4gKiBGb3JtYXQgdGltZXN0YW1wIGZvciBkaXNwbGF5IGJhc2VkIG9uIHRpbWUgc2NhbGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdFRpbWVGb3JTY2FsZShkYXRlOiBEYXRlLCBzY2FsZTogVGltZVNjYWxlKTogc3RyaW5nIHtcbiAgaWYgKHNjYWxlID09PSAnMW0nKSB7XG4gICAgcmV0dXJuIGAke2RhdGUuZ2V0TWludXRlcygpfToke1N0cmluZyhkYXRlLmdldFNlY29uZHMoKSkucGFkU3RhcnQoMiwgJzAnKX1gO1xuICB9IGVsc2UgaWYgKHNjYWxlID09PSAnMjRoJykge1xuICAgIHJldHVybiBgJHtTdHJpbmcoZGF0ZS5nZXRIb3VycygpKS5wYWRTdGFydCgyLCAnMCcpfToke1N0cmluZyhkYXRlLmdldE1pbnV0ZXMoKSkucGFkU3RhcnQoMiwgJzAnKX1gO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBgJHtkYXRlLmdldEhvdXJzKCl9OiR7U3RyaW5nKGRhdGUuZ2V0TWludXRlcygpKS5wYWRTdGFydCgyLCAnMCcpfWA7XG4gIH1cbn1cblxuLyoqXG4gKiBHZW5lcmF0ZSBhIHNpbmdsZSBkYXRhIHBvaW50IGZvciBhIHNwZWNpZmljIHRpbWVzdGFtcFxuICovXG5mdW5jdGlvbiBnZW5lcmF0ZURhdGFQb2ludChcbiAgdGltZXN0YW1wOiBudW1iZXIsXG4gIHNjYWxlOiBUaW1lU2NhbGUsXG4gIHByb2ZpbGU6IENyb3BTdGVlcmluZ1Byb2ZpbGUsXG4gIHJuZzogU2VlZGVkUmFuZG9tXG4pOiBDcm9wU3RlZXJpbmdEYXRhUG9pbnQge1xuICBjb25zdCBkYXRlID0gbmV3IERhdGUodGltZXN0YW1wKTtcbiAgY29uc3QgaG91ciA9IGRhdGUuZ2V0SG91cnMoKSArIGRhdGUuZ2V0TWludXRlcygpIC8gNjA7XG4gIGNvbnN0IHBoYXNlID0gZ2V0UGhhc2UoaG91ciwgcHJvZmlsZSk7XG4gIFxuICBjb25zdCB7IHZ3YywgaXJyaWdhdGlvbkV2ZW50IH0gPSBjYWxjdWxhdGVWd2ModGltZXN0YW1wLCBwcm9maWxlLCBybmcpO1xuICBjb25zdCBlbnZpcm9ubWVudGFscyA9IGNhbGN1bGF0ZUVudmlyb25tZW50YWxzKHRpbWVzdGFtcCwgcHJvZmlsZSwgcm5nKTtcbiAgXG4gIHJldHVybiB7XG4gICAgdGltZXN0YW1wLFxuICAgIHRpbWU6IGZvcm1hdFRpbWVGb3JTY2FsZShkYXRlLCBzY2FsZSksXG4gICAgdndjLFxuICAgIHBoYXNlLFxuICAgIGlycmlnYXRpb25FdmVudCxcbiAgICAuLi5lbnZpcm9ubWVudGFscyxcbiAgfTtcbn1cblxuLy8gQ2FjaGUgZm9yIHN0b3JpbmcgaGlnaC1yZXNvbHV0aW9uIGJhc2UgZGF0YVxubGV0IGJhc2VEYXRhQ2FjaGU6IENyb3BTdGVlcmluZ0RhdGFQb2ludFtdID0gW107XG5sZXQgYmFzZUNhY2hlVGltZXN0YW1wOiBudW1iZXIgPSAwO1xuY29uc3QgQkFTRV9SRVNPTFVUSU9OX01TID0gMTAwMDsgLy8gMSBzZWNvbmQgcmVzb2x1dGlvbiBmb3IgYmFzZSBkYXRhXG5jb25zdCBCQVNFX0RBVEFfRFVSQVRJT05fTVMgPSAyNCAqIDYwICogNjAgKiAxMDAwOyAvLyAyNCBob3VycyBvZiBkYXRhXG5cbi8qKlxuICogR2VuZXJhdGUgb3IgcmV0cmlldmUgYmFzZSBoaWdoLXJlc29sdXRpb24gZGF0YVxuICogVGhpcyBlbnN1cmVzIGNvbnNpc3RlbmN5IGFjcm9zcyBhbGwgdGltZSBzY2FsZXNcbiAqL1xuZnVuY3Rpb24gZ2V0QmFzZURhdGEocHJvZmlsZTogQ3JvcFN0ZWVyaW5nUHJvZmlsZSA9IERFRkFVTFRfUFJPRklMRSk6IENyb3BTdGVlcmluZ0RhdGFQb2ludFtdIHtcbiAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgXG4gIC8vIFJlZ2VuZXJhdGUgaWYgY2FjaGUgaXMgc3RhbGUgKG9sZGVyIHRoYW4gMzAgc2Vjb25kcykgb3IgZW1wdHlcbiAgaWYgKCFiYXNlRGF0YUNhY2hlLmxlbmd0aCB8fCBub3cgLSBiYXNlQ2FjaGVUaW1lc3RhbXAgPiAzMDAwMCkge1xuICAgIGJhc2VDYWNoZVRpbWVzdGFtcCA9IG5vdztcbiAgICBcbiAgICAvLyBVc2UgYSBzZWVkIGJhc2VkIG9uIHRoZSBzdGFydCBvZiB0aGUgY3VycmVudCBkYXkgZm9yIGNvbnNpc3RlbmN5XG4gICAgY29uc3QgZGF5U3RhcnQgPSBuZXcgRGF0ZSgpO1xuICAgIGRheVN0YXJ0LnNldEhvdXJzKDAsIDAsIDAsIDApO1xuICAgIGNvbnN0IHNlZWQgPSBkYXlTdGFydC5nZXRUaW1lKCk7XG4gICAgY29uc3Qgcm5nID0gbmV3IFNlZWRlZFJhbmRvbShzZWVkKTtcbiAgICBcbiAgICBiYXNlRGF0YUNhY2hlID0gW107XG4gICAgY29uc3Qgc3RhcnRUaW1lID0gbm93IC0gQkFTRV9EQVRBX0RVUkFUSU9OX01TO1xuICAgIFxuICAgIC8vIEdlbmVyYXRlIGRhdGEgYXQgMS1taW51dGUgcmVzb2x1dGlvbiBmb3IgZWZmaWNpZW5jeSAodXBncmFkZSBmcm9tIDFzKVxuICAgIGNvbnN0IHJlc29sdXRpb25NcyA9IDYwMDAwOyAvLyAxIG1pbnV0ZVxuICAgIGNvbnN0IGRhdGFQb2ludHMgPSBNYXRoLmZsb29yKEJBU0VfREFUQV9EVVJBVElPTl9NUyAvIHJlc29sdXRpb25Ncyk7XG4gICAgXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhUG9pbnRzOyBpKyspIHtcbiAgICAgIGNvbnN0IHRpbWVzdGFtcCA9IHN0YXJ0VGltZSArIChpICogcmVzb2x1dGlvbk1zKTtcbiAgICAgIGJhc2VEYXRhQ2FjaGUucHVzaChnZW5lcmF0ZURhdGFQb2ludCh0aW1lc3RhbXAsICcxbScsIHByb2ZpbGUsIHJuZykpO1xuICAgIH1cbiAgfVxuICBcbiAgcmV0dXJuIGJhc2VEYXRhQ2FjaGU7XG59XG5cbi8qKlxuICogQWdncmVnYXRlIGRhdGEgcG9pbnRzIGJ5IGF2ZXJhZ2luZyB2YWx1ZXMgd2l0aGluIHRpbWUgYnVja2V0c1xuICovXG5mdW5jdGlvbiBhZ2dyZWdhdGVEYXRhUG9pbnRzKFxuICBkYXRhOiBDcm9wU3RlZXJpbmdEYXRhUG9pbnRbXSxcbiAgYnVja2V0U2l6ZU1zOiBudW1iZXIsXG4gIHNjYWxlOiBUaW1lU2NhbGVcbik6IENyb3BTdGVlcmluZ0RhdGFQb2ludFtdIHtcbiAgaWYgKGRhdGEubGVuZ3RoID09PSAwKSByZXR1cm4gW107XG4gIFxuICBjb25zdCBidWNrZXRzOiBNYXA8bnVtYmVyLCBDcm9wU3RlZXJpbmdEYXRhUG9pbnRbXT4gPSBuZXcgTWFwKCk7XG4gIFxuICAvLyBHcm91cCBkYXRhIGludG8gYnVja2V0c1xuICBmb3IgKGNvbnN0IHBvaW50IG9mIGRhdGEpIHtcbiAgICBjb25zdCBidWNrZXRLZXkgPSBNYXRoLmZsb29yKHBvaW50LnRpbWVzdGFtcCAvIGJ1Y2tldFNpemVNcykgKiBidWNrZXRTaXplTXM7XG4gICAgaWYgKCFidWNrZXRzLmhhcyhidWNrZXRLZXkpKSB7XG4gICAgICBidWNrZXRzLnNldChidWNrZXRLZXksIFtdKTtcbiAgICB9XG4gICAgYnVja2V0cy5nZXQoYnVja2V0S2V5KSEucHVzaChwb2ludCk7XG4gIH1cbiAgXG4gIC8vIEFnZ3JlZ2F0ZSBlYWNoIGJ1Y2tldFxuICBjb25zdCByZXN1bHQ6IENyb3BTdGVlcmluZ0RhdGFQb2ludFtdID0gW107XG4gIGNvbnN0IHNvcnRlZEtleXMgPSBBcnJheS5mcm9tKGJ1Y2tldHMua2V5cygpKS5zb3J0KChhLCBiKSA9PiBhIC0gYik7XG4gIFxuICBmb3IgKGNvbnN0IGJ1Y2tldEtleSBvZiBzb3J0ZWRLZXlzKSB7XG4gICAgY29uc3QgcG9pbnRzID0gYnVja2V0cy5nZXQoYnVja2V0S2V5KSE7XG4gICAgY29uc3QgYXZnUG9pbnQ6IENyb3BTdGVlcmluZ0RhdGFQb2ludCA9IHtcbiAgICAgIHRpbWVzdGFtcDogYnVja2V0S2V5LFxuICAgICAgdGltZTogZm9ybWF0VGltZUZvclNjYWxlKG5ldyBEYXRlKGJ1Y2tldEtleSksIHNjYWxlKSxcbiAgICAgIHZ3YzogcG9pbnRzLnJlZHVjZSgoc3VtLCBwKSA9PiBzdW0gKyBwLnZ3YywgMCkgLyBwb2ludHMubGVuZ3RoLFxuICAgICAgdGVtcDogcG9pbnRzLnJlZHVjZSgoc3VtLCBwKSA9PiBzdW0gKyBwLnRlbXAsIDApIC8gcG9pbnRzLmxlbmd0aCxcbiAgICAgIHJoOiBwb2ludHMucmVkdWNlKChzdW0sIHApID0+IHN1bSArIHAucmgsIDApIC8gcG9pbnRzLmxlbmd0aCxcbiAgICAgIHZwZDogcG9pbnRzLnJlZHVjZSgoc3VtLCBwKSA9PiBzdW0gKyBwLnZwZCwgMCkgLyBwb2ludHMubGVuZ3RoLFxuICAgICAgY28yOiBwb2ludHMucmVkdWNlKChzdW0sIHApID0+IHN1bSArIHAuY28yLCAwKSAvIHBvaW50cy5sZW5ndGgsXG4gICAgICBwcGZkOiBwb2ludHMucmVkdWNlKChzdW0sIHApID0+IHN1bSArIHAucHBmZCwgMCkgLyBwb2ludHMubGVuZ3RoLFxuICAgICAgcGhhc2U6IHBvaW50c1tNYXRoLmZsb29yKHBvaW50cy5sZW5ndGggLyAyKV0ucGhhc2UsIC8vIFVzZSBtaWRkbGUgcG9pbnQncyBwaGFzZVxuICAgICAgaXJyaWdhdGlvbkV2ZW50OiBwb2ludHMuc29tZShwID0+IHAuaXJyaWdhdGlvbkV2ZW50KSxcbiAgICB9O1xuICAgIHJlc3VsdC5wdXNoKGF2Z1BvaW50KTtcbiAgfVxuICBcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZSBoaWdoLXJlc29sdXRpb24gZGF0YSBmb3IgMW0gc2NhbGUgKDEtc2Vjb25kIGludGVydmFscylcbiAqIFRoaXMgaXMgZ2VuZXJhdGVkIG9uLWRlbWFuZCBzaW5jZSBpdCdzIGEgc2hvcnQgdGltZSB3aW5kb3dcbiAqL1xuZnVuY3Rpb24gZ2VuZXJhdGUxbURhdGEocHJvZmlsZTogQ3JvcFN0ZWVyaW5nUHJvZmlsZSk6IENyb3BTdGVlcmluZ0RhdGFQb2ludFtdIHtcbiAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgY29uc3QgY29uZmlnID0gVElNRV9TQ0FMRVNbJzFtJ107XG4gIGNvbnN0IGludGVydmFsTXMgPSBjb25maWcuaW50ZXJ2YWxNczsgLy8gMTAwMG1zXG4gIGNvbnN0IGRhdGFQb2ludHMgPSBjb25maWcuZGF0YVBvaW50czsgLy8gNjAgcG9pbnRzXG4gIFxuICAvLyBVc2UgYSBzZWVkIGJhc2VkIG9uIHRoZSBjdXJyZW50IG1pbnV0ZSBmb3IgY29uc2lzdGVuY3kgd2l0aGluIHRoYXQgbWludXRlXG4gIGNvbnN0IG1pbnV0ZVN0YXJ0ID0gTWF0aC5mbG9vcihub3cgLyA2MDAwMCkgKiA2MDAwMDtcbiAgY29uc3Qgcm5nID0gbmV3IFNlZWRlZFJhbmRvbShtaW51dGVTdGFydCk7XG4gIFxuICBjb25zdCByZXN1bHQ6IENyb3BTdGVlcmluZ0RhdGFQb2ludFtdID0gW107XG4gIGNvbnN0IHN0YXJ0VGltZSA9IG5vdyAtIChkYXRhUG9pbnRzICogaW50ZXJ2YWxNcyk7XG4gIFxuICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGFQb2ludHM7IGkrKykge1xuICAgIGNvbnN0IHRpbWVzdGFtcCA9IHN0YXJ0VGltZSArIChpICogaW50ZXJ2YWxNcyk7XG4gICAgcmVzdWx0LnB1c2goZ2VuZXJhdGVEYXRhUG9pbnQodGltZXN0YW1wLCAnMW0nLCBwcm9maWxlLCBybmcpKTtcbiAgfVxuICBcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBNYWluIGZ1bmN0aW9uOiBHZXQgY3JvcCBzdGVlcmluZyBkYXRhIGZvciBhIHNwZWNpZmljIHRpbWUgc2NhbGVcbiAqIERhdGEgaXMgY29uc2lzdGVudCBhY3Jvc3MgdGltZSBzY2FsZXMgLSBzaG9ydGVyIHNjYWxlcyBzaG93IG1vcmUgZGV0YWlsLFxuICogbG9uZ2VyIHNjYWxlcyBzaG93IGFnZ3JlZ2F0ZWQvZG93bnNhbXBsZWQgZGF0YVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q3JvcFN0ZWVyaW5nRGF0YShcbiAgc2NhbGU6IFRpbWVTY2FsZSxcbiAgcHJvZmlsZTogQ3JvcFN0ZWVyaW5nUHJvZmlsZSA9IERFRkFVTFRfUFJPRklMRVxuKTogQ3JvcFN0ZWVyaW5nRGF0YVBvaW50W10ge1xuICBjb25zdCBjb25maWcgPSBUSU1FX1NDQUxFU1tzY2FsZV07XG4gIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gIGNvbnN0IHdpbmRvd01zID0gY29uZmlnLm1pbnV0ZXMgKiA2MCAqIDEwMDA7XG4gIGNvbnN0IHN0YXJ0VGltZSA9IG5vdyAtIHdpbmRvd01zO1xuICBcbiAgLy8gU3BlY2lhbCBoYW5kbGluZyBmb3IgMW0gc2NhbGUgLSBnZW5lcmF0ZSBhdCAxLXNlY29uZCByZXNvbHV0aW9uXG4gIGlmIChzY2FsZSA9PT0gJzFtJykge1xuICAgIHJldHVybiBnZW5lcmF0ZTFtRGF0YShwcm9maWxlKTtcbiAgfVxuICBcbiAgLy8gR2V0IGJhc2UgZGF0YSAoMS1taW51dGUgcmVzb2x1dGlvbilcbiAgY29uc3QgYmFzZURhdGEgPSBnZXRCYXNlRGF0YShwcm9maWxlKTtcbiAgXG4gIC8vIEZpbHRlciB0byB0aW1lIHdpbmRvd1xuICBjb25zdCB3aW5kb3dEYXRhID0gYmFzZURhdGEuZmlsdGVyKHAgPT4gcC50aW1lc3RhbXAgPj0gc3RhcnRUaW1lICYmIHAudGltZXN0YW1wIDw9IG5vdyk7XG4gIFxuICAvLyBJZiB3ZSBkb24ndCBoYXZlIGVub3VnaCBkYXRhIHBvaW50cywgcmV0dXJuIHdoYXQgd2UgaGF2ZVxuICBpZiAod2luZG93RGF0YS5sZW5ndGggPT09IDApIHtcbiAgICAvLyBHZW5lcmF0ZSBzb21lIGRhdGEgZm9yIHRoZSB3aW5kb3dcbiAgICBjb25zdCBybmcgPSBuZXcgU2VlZGVkUmFuZG9tKE1hdGguZmxvb3Iobm93IC8gNjAwMDApKTtcbiAgICBjb25zdCByZXN1bHQ6IENyb3BTdGVlcmluZ0RhdGFQb2ludFtdID0gW107XG4gICAgY29uc3QgaW50ZXJ2YWxNcyA9IHdpbmRvd01zIC8gY29uZmlnLmRhdGFQb2ludHM7XG4gICAgXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb25maWcuZGF0YVBvaW50czsgaSsrKSB7XG4gICAgICBjb25zdCB0aW1lc3RhbXAgPSBzdGFydFRpbWUgKyAoaSAqIGludGVydmFsTXMpO1xuICAgICAgcmVzdWx0LnB1c2goZ2VuZXJhdGVEYXRhUG9pbnQodGltZXN0YW1wLCBzY2FsZSwgcHJvZmlsZSwgcm5nKSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgXG4gIC8vIENhbGN1bGF0ZSBidWNrZXQgc2l6ZSBmb3IgYWdncmVnYXRpb25cbiAgY29uc3QgYnVja2V0U2l6ZU1zID0gd2luZG93TXMgLyBjb25maWcuZGF0YVBvaW50cztcbiAgXG4gIC8vIEFnZ3JlZ2F0ZSBpZiBuZWVkZWQgKGZvciBsb25nZXIgdGltZSBzY2FsZXMpXG4gIGlmIChidWNrZXRTaXplTXMgPiA2MDAwMCkge1xuICAgIHJldHVybiBhZ2dyZWdhdGVEYXRhUG9pbnRzKHdpbmRvd0RhdGEsIGJ1Y2tldFNpemVNcywgc2NhbGUpO1xuICB9XG4gIFxuICAvLyBGb3Igc2hvcnQgdGltZSBzY2FsZXMsIGp1c3Qgc2FtcGxlXG4gIGNvbnN0IHRhcmdldENvdW50ID0gY29uZmlnLmRhdGFQb2ludHM7XG4gIGlmICh3aW5kb3dEYXRhLmxlbmd0aCA8PSB0YXJnZXRDb3VudCkge1xuICAgIHJldHVybiB3aW5kb3dEYXRhLm1hcChwID0+ICh7XG4gICAgICAuLi5wLFxuICAgICAgdGltZTogZm9ybWF0VGltZUZvclNjYWxlKG5ldyBEYXRlKHAudGltZXN0YW1wKSwgc2NhbGUpLFxuICAgIH0pKTtcbiAgfVxuICBcbiAgLy8gRG93bnNhbXBsZSBldmVubHlcbiAgY29uc3QgcmVzdWx0OiBDcm9wU3RlZXJpbmdEYXRhUG9pbnRbXSA9IFtdO1xuICBjb25zdCBzdGVwID0gd2luZG93RGF0YS5sZW5ndGggLyB0YXJnZXRDb3VudDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB0YXJnZXRDb3VudDsgaSsrKSB7XG4gICAgY29uc3QgaWR4ID0gTWF0aC5mbG9vcihpICogc3RlcCk7XG4gICAgY29uc3QgcG9pbnQgPSB3aW5kb3dEYXRhW2lkeF07XG4gICAgcmVzdWx0LnB1c2goe1xuICAgICAgLi4ucG9pbnQsXG4gICAgICB0aW1lOiBmb3JtYXRUaW1lRm9yU2NhbGUobmV3IERhdGUocG9pbnQudGltZXN0YW1wKSwgc2NhbGUpLFxuICAgIH0pO1xuICB9XG4gIFxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIENsZWFyIHRoZSBjYWNoZSAtIHVzZWZ1bCBmb3IgdGVzdGluZyBvciBmb3JjaW5nIGRhdGEgcmVnZW5lcmF0aW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbGVhckNyb3BTdGVlcmluZ0NhY2hlKCk6IHZvaWQge1xuICBiYXNlRGF0YUNhY2hlID0gW107XG4gIGJhc2VDYWNoZVRpbWVzdGFtcCA9IDA7XG59XG5cbi8qKlxuICogR2V0IGN1cnJlbnQgVldDIHZhbHVlIChsYXRlc3QgZnJvbSBiYXNlIGRhdGEpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRDdXJyZW50VndjKCk6IG51bWJlciB7XG4gIGNvbnN0IGRhdGEgPSBnZXRCYXNlRGF0YSgpO1xuICByZXR1cm4gZGF0YS5sZW5ndGggPiAwID8gZGF0YVtkYXRhLmxlbmd0aCAtIDFdLnZ3YyA6IDUwO1xufVxuXG5leHBvcnQgeyBERUZBVUxUX1BST0ZJTEUsIHR5cGUgQ3JvcFN0ZWVyaW5nUHJvZmlsZSB9O1xuIl0sIm5hbWVzIjpbIlRJTUVfU0NBTEVTIiwibGFiZWwiLCJtaW51dGVzIiwiZGF0YVBvaW50cyIsImludGVydmFsTXMiLCJTZWVkZWRSYW5kb20iLCJuZXh0Iiwic2VlZCIsImdhdXNzaWFuIiwibWluIiwibWF4Iiwic3RkRGV2IiwidTEiLCJ1MiIsInowIiwiTWF0aCIsInNxcnQiLCJsb2ciLCJjb3MiLCJQSSIsImNlbnRlcmVkIiwiY2xhbXBlZCIsImNvbnN0cnVjdG9yIiwiREVGQVVMVF9QUk9GSUxFIiwibGlnaHRzT25Ib3VyIiwibGlnaHRzT2ZmSG91ciIsInAxRHVyYXRpb24iLCJwMkR1cmF0aW9uIiwicDFUYXJnZXRWd2MiLCJwMlRhcmdldFZ3YyIsInAzVGFyZ2V0VndjIiwic2hvdFZ3Y0luY3JlYXNlIiwiZHJ5YmFja1JhdGVQZXJIb3VyIiwiZ2V0UGhhc2UiLCJob3VyIiwicHJvZmlsZSIsIm1pbnV0ZXNTaW5jZUxpZ2h0c09uIiwiY2FsY3VsYXRlVndjIiwidGltZXN0YW1wIiwicm5nIiwiZGF0ZSIsIkRhdGUiLCJnZXRIb3VycyIsImdldE1pbnV0ZXMiLCJwaGFzZSIsImJhc2VWd2MiLCJpcnJpZ2F0aW9uRXZlbnQiLCJtaW51dGVPZkhvdXIiLCJob3Vyc0ludG9OaWdodCIsInByb2dyZXNzSW5QMSIsInNob3RJbnRlcnZhbCIsInNob3ROdW1iZXIiLCJmbG9vciIsIm1pbnV0ZXNTaW5jZUxhc3RTaG90Iiwic3RhcnRWd2MiLCJ2d2NGcm9tU2hvdHMiLCJkcnliYWNrU2luY2VMYXN0U2hvdCIsIm1pbnV0ZXNTaW5jZVAxRW5kIiwiY3ljbGVQb3NpdGlvbiIsImRyeWJhY2tJbkN5Y2xlIiwibWludXRlc1NpbmNlUDJFbmQiLCJwM1RvdGFsTWludXRlcyIsInByb2dyZXNzSW5QMyIsIm5vaXNlIiwidndjIiwiY2FsY3VsYXRlRW52aXJvbm1lbnRhbHMiLCJpc0xpZ2h0c09uIiwiYmFzZVRlbXAiLCJ0ZW1wIiwiYmFzZVJoIiwicmgiLCJ2cGQiLCJjbzIiLCJwcGZkIiwiZm9ybWF0VGltZUZvclNjYWxlIiwic2NhbGUiLCJTdHJpbmciLCJnZXRTZWNvbmRzIiwicGFkU3RhcnQiLCJnZW5lcmF0ZURhdGFQb2ludCIsImVudmlyb25tZW50YWxzIiwidGltZSIsImJhc2VEYXRhQ2FjaGUiLCJiYXNlQ2FjaGVUaW1lc3RhbXAiLCJCQVNFX1JFU09MVVRJT05fTVMiLCJCQVNFX0RBVEFfRFVSQVRJT05fTVMiLCJnZXRCYXNlRGF0YSIsIm5vdyIsImxlbmd0aCIsImRheVN0YXJ0Iiwic2V0SG91cnMiLCJnZXRUaW1lIiwic3RhcnRUaW1lIiwicmVzb2x1dGlvbk1zIiwiaSIsInB1c2giLCJhZ2dyZWdhdGVEYXRhUG9pbnRzIiwiZGF0YSIsImJ1Y2tldFNpemVNcyIsImJ1Y2tldHMiLCJNYXAiLCJwb2ludCIsImJ1Y2tldEtleSIsImhhcyIsInNldCIsImdldCIsInJlc3VsdCIsInNvcnRlZEtleXMiLCJBcnJheSIsImZyb20iLCJrZXlzIiwic29ydCIsImEiLCJiIiwicG9pbnRzIiwiYXZnUG9pbnQiLCJyZWR1Y2UiLCJzdW0iLCJwIiwic29tZSIsImdlbmVyYXRlMW1EYXRhIiwiY29uZmlnIiwibWludXRlU3RhcnQiLCJnZXRDcm9wU3RlZXJpbmdEYXRhIiwid2luZG93TXMiLCJiYXNlRGF0YSIsIndpbmRvd0RhdGEiLCJmaWx0ZXIiLCJ0YXJnZXRDb3VudCIsIm1hcCIsInN0ZXAiLCJpZHgiLCJjbGVhckNyb3BTdGVlcmluZ0NhY2hlIiwiZ2V0Q3VycmVudFZ3YyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./features/telemetry/services/crop-steering-data.service.ts\n"));

/***/ })

});